<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../resources/bootstrap.css" type="text/css" />
  <link rel="stylesheet" href="../resources/main.css" type="text/css" />
</head>
<body>
<div id="content">

<div id="header">
<a href="../index.html"><h1 id="docstitle">Denali Documentation</h1></a>
</div>

<h2 id="tutorial">Tutorial</h2>
<p>This tutorial serves as an in-depth first introduction to denali. Along the way, you will gain an understanding for how to interpret the visualization produced by <em>denali</em>, how to use the graphical interface, and how to use <em>denali</em>'s tools to visualize other sources of data, such as a scalar functions defined on point clouds.</p>
<p>The files we will use in this tutorial are located in the <code>examples/tutorial</code> directory.</p>
<hr />
<p><strong>Table of contents</strong>:</p>
<ul>
<li><a href="#introduction-to-landscape-metaphors">Introduction to landscape metaphors</a>
<ul>
<li><a href="#scalar-trees">Scalar trees</a></li>
<li><a href="#interpreting-landscapes">Interpreting landscapes</a></li>
</ul></li>
<li><a href="#basic-usage">Basic usage</a>
<ul>
<li><a href="#the-input-tree">The input tree</a></li>
<li><a href="#loading-the-tree">Loading the tree</a></li>
<li><a href="#exploring-the-landscape">Exploring the landscape</a></li>
<li><a href="#selecting-a-component">Selecting a component</a></li>
<li><a href="#interpreting-the-landscape">Interpreting the landscape</a></li>
<li><a href="#simplifying-the-visualization">Simplifying the visualization</a></li>
<li><a href="#choosing-a-root">Choosing a root</a></li>
<li><a href="#rebasing-the-landscape">Rebasing the landscape</a></li>
</ul></li>
<li><a href="#specifying-custom-behavior">Specifying custom behavior</a>
<ul>
<li><a href="#specifying-a-weight-map">Specifying a weight map</a></li>
<li><a href="#specifying-a-color-map">Specifying a color map</a></li>
<li><a href="#printing-special-information-about-a-selection">Printing special information about a selection</a></li>
</ul></li>
<li><a href="#visualizing-functions-on-point-clouds">Visualizing functions on point clouds</a>
<ul>
<li><a href="#introduction-to-contour-trees">Introduction to contour trees</a></li>
<li><a href="#building-a-neighbor-graph">Building a neighbor graph</a></li>
<li><a href="#computing-the-contour-tree">Computing the contour tree</a></li>
</ul></li>
</ul>
<hr />
<h1 id="introduction-to-landscape-metaphors">Introduction to landscape metaphors</h1>
<p>As described in the <a href="intro.html">introduction</a>, <em>denali</em> is a tool for visualizing data that meets two prerequisites. First, each data point must have an associate scalar value, whether it be a probability, score, cost, etc. Second, it must be possible to extract some tree-like structure from the data. <a href="#visualizing-functions-on-point-clouds">Later</a> in this tutorial, we'll see how to extract tree-like structure from such things as scalar functions defined on point clouds. For now, we'll assume that our data is already in tree-like form.</p>
<h2 id="scalar-trees">Scalar trees</h2>
<p>The fundamental unit of input in <em>denali</em> is the <em>scalar tree</em>. A scalar tree is a tree for which every node has an associated integer ID and scalar value. An example of a scalar tree is shown below.</p>
<center>
<img style="margin:20pt 20pt" width=400 src="../resources/tree.png">
</center>

<p>Here, we see that each node has an integer ID and an associated real number as a value. The edges of scalar trees may also have zero or more &quot;member&quot; vertices. These are vertices which exist within the edges of a tree. Like ordinary vertices, members must have an associated ID and scalar value.</p>
<h2 id="interpreting-landscapes">Interpreting landscapes</h2>
<p><em>Denal</em> visualizes scalar trees like those described above as landscape metaphors. To understand a landscape metaphor, let's build one from a simple scalar tree:</p>
<center>
<img style="margin:20pt 20pt" width=300 src="../resources/interpret_tree.png">
</center>

<p>The tree we'll use is shown above. The exact scalar values associated with each edge aren't important, but note that the tree is laid out so that the scalar value increases from top to bottom. That is, the scalar value associated with node 0, denoted by <em>f(0)</em>, is less than the scalar value associated with node 1. Node 7 has the highest scalar value.</p>
<p>To build a landscape visualization, we first choose a node to be the root. The node with the minimum scalar value is often a natural choice. Let's make 0 the root node of our tree.</p>
<p>Next, we draw a rectangular tree map, shown below:</p>
<center>
<img style="margin:20pt 20pt" width=300 src="../resources/interpret_map.png">
</center>

<p>Each node in the tree is mapped to either a rectangle or a point in the treemap. The root node and all branch nodes are represented as rectangles, while leaf nodes are represented as points.</p>
<p>If a node is a branch, its corresponding rectangle in the treemap is split into several pieces: one piece for every child it has in the tree. For example, node 2 has two children: 3 and 4. The rectangle for node 2 is therefore split into two pieces. The points representing 3 and 4 are placed in their respective divisions of node 2's rectangle.</p>
<p>Nesting represents the subtree property. That is, if a point or rectangle representing node <em>x</em> is nested within the rectangle representing node <em>y</em>, then node <em>x</em> is a successor of node <em>y</em> in the directed tree. If <em>x</em>'s rectangle or point is nested <em>directly</em> within <em>y</em>'s rectangle, then <em>x</em> is a child of <em>y</em>.</p>
<p>Note that there is a gap between, for instance, node 1's rectangle and node 5's rectangle. The area of this gap encodes the <em>weight</em> of the members in the edge from 1 to 5. By default, an edge's weight is simply one plus the number of members contained in the edge. Later we will see how to change the weight of specific member vertices so that the weight of an edge becomes a weighted sum of the weights of its members.</p>
<p>The area of a node's rectangle represents its <em>total weight</em>: the sum of all edge weights and node weights in the subtree rooted at the node, less the node itself. Simply speaking, the larger a rectangle, the more nodes and members in the subtree rooted at that node. From this, we can conclude that since rectangle 5 is larger than rectangle 2, the edges from 5 to 6 and 7 contain more members than the edges from 2 to 3 and 4.</p>
<p>The last step is to &quot;lift&quot; each rectangle and point to a height corresponding to the node's scalar value. By connecting the rectangles and points in the natural way, a surface is produced. The landscape surface for the example tree is shown below:</p>
<center>
<img style="margin:20pt 20pt" width=400 src="../resources/interpret_landscape.png">
</center>

<p>If we were to look at the landscape from above, we'd see the treemap as shown before. But from the side, we have access to additional information: the height of points on the landscape encodes the scalar value of nodes in the tree.</p>
<p>Next, we'll see how to use denali's interface to visualize a simple scalar tree.</p>
<h1 id="basic-usage">Basic usage</h1>
<h2 id="the-input-tree">The input tree</h2>
<p>The tree we will be visualizing is shown below:</p>
<center>
<img style="margin:20pt 20pt" width=400 src="../resources/tree.png">
</center>

<p>Of course, this tree is simpler than the usual sort of input we'll want to visualize with <em>denali</em>, but it is useful for demonstration purposes.</p>
<p>Each node has a positive integer id and a scalar value. In this case, the values are also positive integers, but in general they can be arbitrary real numbers. We also see that some edges have labels next to them. These represent the edges <em>members</em>: lists of vertices that are hidden within each edge. Each member has an unique id, distinct from the ids of the vertices in the tree, and an associated scalar value.</p>
<p>The undirected version of the above tree is represented in <code>examples/tutorial/tree.tree</code>.</p>
<p>If we look inside the file, this is what we see:</p>
<pre><code>9
11  30
10  53
9   51
8   58
7   39
5   32
4   16
3   66
1   62
11  7
10  3   6   64
10  7
9   10
8   7
5   4   0   25
5   1   2   45
5   7</code></pre>
<p>In brief, the format of the <code>tree.tree</code> file is as follows: the first line states the number of vertices in the tree. The next nine lines define the vertices: the first number is the id, and the second is the scalar value. The two numbers are separated by a tab. The remainder of the lines list the edges in the undirected tree. The first two numbers on each line are the ids of the vertices defining the edge. The trailing pairs of numbers on the line (if there are any) define the edge's members: the first number in the pair is the member's id, the second number is the member's value.</p>
<p>For more detailed information on the <code>.tree</code> format, see the <a href="formats.html#tree">format specification</a>.</p>
<h2 id="loading-the-tree">Loading the tree</h2>
<p>With <em>denali</em> running, click <strong>File→Open Tree</strong> and select the <code>tree.tree</code> file in <code>examples/tutorial</code>. You'll see the following:</p>
<center>
<img class="screenshot" src="../resources/tut-open.png">
</center>

<p><em>Denali</em> opens with with a birds-eye view of the landscape. By default, the node in the tree with the minimum scalar value is used as the base of the landscape. We'll see how to change this shortly.</p>
<h2 id="exploring-the-landscape">Exploring the landscape</h2>
<p>To explore the visualization, use the mouse:</p>
<ul>
<li><strong>Hold left mouse</strong>: Click and drag to rotate the landscape</li>
<li><strong>Scroll mouse wheel</strong>: Zoom in and out</li>
<li><strong>Hold mouse wheel</strong>: Translate the landscape</li>
<li><strong>Click right mouse</strong>: Select a component</li>
</ul>
<h2 id="selecting-a-component">Selecting a component</h2>
<p>Right clicking selects a component of the landscape. Each component of the landscape is mapped to an arc of the tree. When a component is selected, general information about the selection is printed in the status box in the lower left of the display.</p>
<p>Click the large blue component at the base of the landscape. The status box prints the following information:</p>
<pre><code>Component Selected: 4 → 5
Parent value: 16
Child value: 32
Persistence: 16
Component weight: 1
Parent total weight: 12
Child total weight: 10</code></pre>
<p>The meaning of each item is as follows:</p>
<ul>
<li><p><strong>Component selected</strong>: The ids of the nodes in the selected component are shown here. When the file was opened, the node with the minimum scalar value was automatically assumed to be the root of the tree. This induces a direction on the edges of the tree. Here, we see that node 4 is the parent of node 5 in the directed tree.</p></li>
<li><p><strong>Parent value</strong>: The scalar value associated with the parent node. Here, this is the scalar value associated with node 4.</p></li>
<li><p><strong>Child value</strong>: The scalar value associated with the child node. Here, this is the scalar value associated with node 5.</p></li>
<li><p><strong>Persistence</strong>: The <em>persistence</em> of the arc is the absolute difference between the parent value and the child value. This is used in simplification, as we'll see shortly.</p></li>
<li><p><strong>Component weight</strong>: The &quot;weight&quot; of a component is the sum of the weights of the members contained within the component. By default, a node or member's weight is simply one. If we look at the tree we used as input, we see that the edge between nodes 4 and 5 had a single member. Therefore, the weight of this component is one. Later, we'll see how to specify a positive real number to the vertices and members in the graph, effectively weighting components of the landscape. Note that edges which have no members have a component weight of zero.</p></li>
<li><p><strong>Parent total weight</strong>: The weight of the parent node, plus the weight of all nodes and members in the subtree rooted at the parent node.</p></li>
<li><p><strong>Child total weight</strong>: The weight of the child node, plus the weight of all nodes and members in the subtree rooted at the child node.</p></li>
</ul>
<h2 id="interpreting-the-landscape">Interpreting the landscape</h2>
<p>The landscape faithfully represents the structure of the tree used as input while intuitively displaying additional information.</p>
<p>A <em>component</em> of the landscape is a single, pyramid-like structure within the terrain. Components are in one-to-one correspondence with the arcs of the tree. Components can be selected by right clicking them, as we learned above. Therefore, selecting a component can be interpreted as selecting an arc in the tree.</p>
<p>Components always have a rectangular base. The top of the component is either a smaller rectangle, or a point; either are nested within the base rectangle when viewed from above or below. These rectangles or points are referred to as <em>contours</em>. Each contour — that is, each bottom and top of a component — corresponds to a node in the tree, as you might expect.</p>
<p>In <em>denali</em>, we've used a rectangular treemap algorithm to map each node in the tree to either a rectangular contour or a point. A branch (degree-2-or-higher) node in the tree is represented as a rectangular contour in the landscape, while leaf nodes are represented by points. The root node is also represented by a rectangular contour: namely the contour at the base of the landscape.</p>
<p>The nesting of the contours is important: a contour is nested in another if it is in the outer rectangle's subtree. If a rectangle or point is nested directly within a larger rectangle, the larger rectangle is the parent of the contour in the tree.</p>
<p>The height of a contour is determined by the associated node's scalar value. The volume of a contour is determined by the total volume of the associated node. The area between two contours when seen from above is determined by the component's weight.</p>
<h2 id="simplifying-the-visualization">Simplifying the visualization</h2>
<p>The tree we are visualizing now isn't very complicated, but sometimes, especially with noisy data, the tree may have many spurious features. These present as small, spiky features in the landscape, and can be distracting.</p>
<p><em>Denali</em> provides a way of suppressing these small features using <em>simplification by persistence</em>. As described above, <em>persistence</em> is the height of component in the landscape: the absolute difference between the parent's scalar value and the child's. A reasonable assumption is that leafy arcs with small persistence aren't very important, while arcs with high persistence are more likely to be of interested.</p>
<p>Simplification in <em>denali</em> is an operation on an entire subtree. First, we'll simplify the entire tree:</p>
<ol style="list-style-type: decimal">
<li>Right click the base of the landscape to select component 4 → 5.</li>
<li>Adjust the simplification threshold slider to about 10.</li>
<li>Click <strong>Refine Subtree</strong>.</li>
</ol>
<p>Your landscape should look like the following:</p>
<center>
<img class="screenshot" src="tut-simplified1.png">
</center>

<p><em>Denali</em> has iteratively collapsed leafy arcs with persistence less than the threshold. Along the way, new leafy arcs are created. For example, exploring the simplified landscape shows that the arc 7 → 3 now exists in our simplified tree. This arc wasn't present in the original tree, but simplification has connected the two. Note that the arc has a component weight of 3: this is because the arc &quot;contains&quot; nodes 9 and 10, as well as the member 6 which was originally in the arc from 10 → 3. In this way, the total weight of node 7 has remained the same. That is to say: simplification of a subtree preserves the subtree's total weight.</p>
<p>A careful reader will note that node 11 is no longer in the landscape and it wasn't listed as a member of the 7 → 3 arc. In actuality, node 11 is internally represented as a member of node 7 and contributes to its total weight.</p>
<p>Simplifications can be made in series, and they apply only to the subtree of the selected component. For example, suppose we wanted to see the structure of the simplified 7 → 3 component in more detail.</p>
<ol style="list-style-type: decimal">
<li>Right click the 7 → 3 component.</li>
<li>Adjust the simplification slider to about 5.</li>
<li>Click <strong>Refine Subtree</strong>.</li>
</ol>
<p>You'll see the following:</p>
<center>
<img class="screenshot" src="tut-simplified2.png">
</center>

<p>The 7 → 3 component was completely expanded, and the subtree was then simplified down using the new threshold of 5. However, other parts of the landscape, which were previously simplified with a threshold of 10, were left untouched.</p>
<p>Lastly, we may wish to start over and view the entire, unsimplified tree. To do this, select the <strong>Expand</strong> button in the simplification pane.</p>
<h2 id="choosing-a-root">Choosing a root</h2>
<p>When a new landscape is opened in <em>denali</em> the node with the minimum scalar value is used as the base of the landscape. Depending on what the tree represents, however, it may be useful to select a different node as the root.</p>
<p>To select a root, click the <strong>Choose Root</strong> button in the <em>Root Selection</em> pane. To use the maximum node as the root, select the <strong>Maximum node</strong> option. Any vertex in the tree may be used as the root. For example, to set node 7 to be the root, click the radio button next to <strong>Other</strong> and insert 7 in the box, then click <strong>Ok</strong>.</p>
<p>As you see, not all root selections lead to interesting or aesthetically-pleasing visualizations. More often than not, the maximum or minimum nodes are the best choices.</p>
<p>Before we continue, set the root of the landscape to be the minimum node.</p>
<h2 id="rebasing-the-landscape">Rebasing the landscape</h2>
<p>Suppose we are interested in a particular subtree or section of the landscape. We can visualize this section alone by <em>rebasing</em> the tree.</p>
<p>For example, suppose we are only interested in the subtree rooted at node 7, and we'd like to get rid of the rest of the landscape:</p>
<ol style="list-style-type: decimal">
<li>Right click to select the 5 → 7 component. In the context of rebasing, this is equivalent to selecting the 7 node.</li>
<li>Click the <strong>Rebase</strong> button in the <em>Root Selection</em> pane.</li>
</ol>
<p>The rebased landscape now appears in the visualization window. To return to visualizing the full landscape, you'll need to open the tree again by selecting <strong>File → Open Tree</strong>. Before proceeding with the tutorial, make sure that you've done so.</p>
<h1 id="specifying-custom-behavior">Specifying Custom Behavior</h1>
<h2 id="specifying-a-weight-map">Specifying a weight map</h2>
<p><strong>Important</strong>: Before continuing, make sure that the full tree is being visualized by selecting <strong>File → Open Tree</strong> and choosing <code>examples/tutorial/tree.tree</code>.</p>
<p>Each vertex and member in the scalar tree has an associated weight. By default, this weight is simply one. If we'd like to draw attention to a part of the landscape, or represent a second scalar function using the volume of the landscape components, we can specify a mapping from vertex or member id to a positive scalar value.</p>
<p>In this example, we'll re-weight node 8 to have weight 40, and member 0 to have weight 20. If you open the file <code>examples/tutorial/tree.weights</code>, this is what you'll see:</p>
<pre><code>0   20
8   40</code></pre>
<p>These two lines specify the weights for the node and member. Note that not every node or member in the tree appears in the file: a partial mapping is sufficient. Any node or member not listed in the mapping is assumed to have unit weight. For more information on the weight map file format, see the <a href="formats.html#weights">specification</a>.</p>
<p>Now we will load the weight map:</p>
<ol style="list-style-type: decimal">
<li>Click <strong>File → Load Weight Map</strong>.</li>
<li>Select <code>examples/tutorial/tree.weights</code>.</li>
</ol>
<p>This is what you'll see:</p>
<center>
<img class="screenshot" src="tut-simplified2.png">
</center>

<p>Node 8 is a leaf node at the top of the landscape. If we select component 7 → 8, we see that the child total weight is 40.</p>
<p>Member 0 is a member of the 4 → 5 arc. If we select this component, we see that the component weight is 20, as expected.</p>
<p>You can make changes to the weight map while <em>denali</em> is running, but to recompute the landscape to reflect the changes, you'll need to reload the weight file by following the steps above. If you'd like to go back to visualizing the unweighted landscape, click <strong>File → Clear Weight Map</strong>.</p>
<h2 id="specifying-a-color-map">Specifying a color map</h2>
<p>By default, the color of the landscape is a function of the height (i.e, the scalar value of the vertices). It is possible, however, to choose a custom color function. This is useful, for example, to visualize a second scalar function on top of the landscape.</p>
<p>As noted above, interactively simplifying the tree may create and destroy arcs. Having the user specify a color map by associating each arc to a color is therefore infeasible. Instead, <em>denali</em> has the user map each node and member of the tree to a second scalar value. The user then selects from a set of rules which assign to each arc of the tree a single scalar value. This value is then used to give the arc a color.</p>
<p>Consider, for example, the arc from 4 → 5 in the example tree above. This arc has has a member. In general, an arc may have many members, or none at all. The user will provide a color map associated to the two nodes and member a second scalar value.</p>
<p>There are many ways to reduce these three values associated with the arc to a single value, thereby mapping the arc to a color. For example, we may simply take the mean of the three values. Alternatively, we might want only the parent and child nodes to contribute to the mean. Even simpler, we might just set the value of the child node to be the representative value of the arc.</p>
<p>In each case, we define a set of <em>contributors</em> and a <em>reduction</em>. The set of contributors includes either the parent, child, or both, and optionally the members in the arc. <em>Denali</em> also provides many reductions, such as max, min, mean, and variance, which reduce the set of scalar values associated with the contributors to a single scalar value.</p>
<p>Let's look at a concrete example. First, we must assign each node and member in the tree a second scalar value. Let's just assign each node and member the same value it has in our original tree. This has already been done for you in <code>examples/tutorial/tree.colors</code>. If you open the file, this is what you'll see:</p>
<pre><code>11  30
10  53
9   51
8   58
7   39
5   32
4   16
3   66
1   62
6   64
0   25
2   45</code></pre>
<p>Each node and member in the tree has it's own line. The first number is the id of the node or member, and the second is the value. For more information on the format of <code>.colors</code> files, see the <a href="formats.html#colors">specification</a>.</p>
<p>To use this color map:</p>
<ol style="list-style-type: decimal">
<li>Select <strong>File → Configure Color Map</strong>.</li>
<li>Click <strong>Browse</strong> and select the <code>examples/tutorial/tree.colors</code> color map.</li>
<li>In the <em>Contributors</em> pane, select <strong>Child</strong> and <em>de</em>select <strong>Include members</strong>.</li>
<li>In the <em>Reduction</em> drop-down menu, select <strong>Maximum</strong>.</li>
</ol>
<p>This is what you'll see:</p>
<center>
<img class="screenshot" src="tut-simplified2.png">
</center>

<p>What we've done is set the color of each component to be the scalar value assigned to the child node. The color map we've specified isn't very interesting, though: each node and member is mapped to the same scalar value it had in the original tree.</p>
<p>Two of the reductions provided by <em>denali</em> are a bit different: the covariance and correlation reductions. These reductions compute the covariance and correlation between the color scalar function and the original scalar function, useful for comparing the two mappings.</p>
<h2 id="printing-special-information-about-a-selection">Printing special information about a selection</h2>
<p><em>Denali</em> includes a powerful and general callback system. It can be used to invoke external commands whenever a component of the landscape is selected. Communication with the invoked process is done via a simple flat file and STDIN/STDOUT, meaning that callbacks may be written in virtually any programming language without any dependencies on a message-passing library.</p>
<p>There are three flavors of callbacks:</p>
<ul>
<li><p><em>Information</em> callbacks provide a string the <em>Denali</em>, which is then printed in the status box.</p></li>
<li><p><em>Void</em> callbacks function just like information callbacks, but their output is ignored. They can still have side-effects, though, like opening a window containing a plot.</p></li>
<li><p><em>Tree</em> callbacks provide as output a tree in <code>.tree</code> format. This tree replaces the one that was previously being visualized.</p></li>
</ul>
<p>A full treatment of the callback system is outside of the scope of this tutorial — for that, see the <a href="callback.html">callback system section</a>. For now, we'll cover the creation of a simple callback in Python. Whenever a component is selected, the callback will print some information about the selection to the status box. We'll therefore be implementing an <em>info</em> callback.</p>
<p>When <em>denali</em> invokes a callback, it prints useful information about the selected component to a temporary file. The location of this file is provided as the first argument to the callback process. Detailed information about the structure of this &quot;selection file&quot; is in the <a href="callback.html">callback section</a>. For now, we don't need to understand exactly how this file is formatted, just know that it contains the ids of the nodes in the selected components.</p>
<p>Included with <em>denali</em> is the <em>denali.py</em> Python module. Among other things, it contains useful functions for interacting with <em>denali</em> data formats. One such function is <code>denali.io.read_selection</code>. This function takes a file-like object representing a selection file and parses it into a dictionary.</p>
<p>The dictionary contains a &quot;component&quot; key representing the selected component. Its value is a 2x2 numpy array whose first column has the ids of the two nodes at either end of the component, and whose second column has the corresponding scalar values of the node.</p>
<p>This is all the information we'll need to write our simple callback. If you look at the <code>examples/tutorial/callback.py</code> file, you'll see:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> sys
<span class="ch">import</span> denali

<span class="kw">with</span> <span class="dt">open</span>(sys.argv[<span class="dv">1</span>]) <span class="ch">as</span> f:
    selection = denali.io.read_selection(f)
    u,v = selection[<span class="st">&#39;component&#39;</span>][:,<span class="dv">0</span>]
    <span class="kw">print</span> <span class="st">&quot;The selection component was {} --&gt; {}.&quot;</span>.<span class="dt">format</span>(
            <span class="dt">int</span>(u), <span class="dt">int</span>(v))</code></pre>
<p>The callback gets the path of the selection file from its first argument. It then reads the selection and prints a simple message to the screen. The standard output of the callback is captured, however, and redirected to the status box in the <em>denali</em>. Therefore, printing information to <em>denali</em>'s status box is as simple as printing to the screen, no matter what language you choose to use.</p>
<p>Now, let's try testing this callback. First thing is first: you'll need the <em>denali</em> python module in your path. There are several ways of doing this. You can pick your favorite, or simply add the line:</p>
<pre class="sourceCode python"><code class="sourceCode python">sys.path.append(<span class="st">&quot;/path/to/denali/python&quot;</span>)</code></pre>
<p>under <code>import sys</code> in the above script.</p>
<p>Now we'll notify <em>denali</em> to use this script as a callback. Click on <strong>File → Configure Callbacks</strong>. You should see the following:</p>
<center>
<img class="screenshot" src="callbacks.png">
</center>

<p>There are three sections, one for each type of callback. Since we'll be specifying an info callback, we are interested in the first section. Click the <strong>Browse</strong> button and find the <code>examples/tutorial/callback.py</code> script. This will place the path to the callback script in the text box. Click inside the textbox and add <code>python2</code> in front of this path, so that the whole line reads something like:</p>
<pre><code>python2 path/to/denali/examples/tutorial/callback.py</code></pre>
<p>Note that under Unix you could just as well place <code>#!/usr/bin/env python2</code> or similar at the top of <code>callback.py</code> and made the file executable. Then you could omit <code>python2</code> from the text box.</p>
<p>Below the text box are two options: <strong>Run on selection</strong> and <strong>Supply subtree</strong>. When the <strong>Run on selection</strong> box is marked, the callback will automatically be invoked when a selection is made. When the <strong>Supply subtree</strong> box is checked, the callback will be provided with a list of all of the nodes and members in the subtree induced by the selection. Check the <strong>Supply subtree</strong> box, and click <strong>Ok</strong>.</p>
<p>Now, right click to select a component of the landscape, and in the status box in the lower left corner, you'll see the text: &quot;The selection component was: &quot;, followed by the ids of the nodes in your selection.</p>
<p>After a selection is made, you can manually invoke the callback again by clicking the <strong>Info</strong> button in the <em>Callbacks</em> pane at the lower right of the interface.</p>
<p>Note that we could have done <em>anything</em> in our Python callback, such as plotted relevant data in a new window, download information from the internet, or even spawn a new <em>denali</em> process. And while the included utility functions make parsing the selection information very easy, any other language is also capable of reading and interaction with <em>denali</em> in this way.</p>
<h1 id="visualizing-functions-on-point-clouds">Visualizing Functions on Point Clouds</h1>
<h2 id="introduction-to-contour-trees">Introduction to contour trees</h2>
<p>As we have seen, <em>denali</em>'s input is a scalar tree: an undirected graph whose nodes each have an associated real number. We can use the concept of a <em>contour tree</em> to visualize scalar functions defined on other structures, including point clouds.</p>
<p>Consider a scalar function <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f" alt="f" title="f" /> defined on a subset of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cmathbb%7BR%7D%5Ed" alt="\mathbb{R}^d" title="\mathbb{R}^d" />. We can define the <em>level set</em> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f%5E%7B-1%7D%28a%29%20%3D%20%5C%7B%20x%20%7C%20f%28x%29%20%3D%20a%20%5C%7D" alt="f^{-1}(a) = \{ x | f(x) = a \}" title="f^{-1}(a) = \{ x | f(x) = a \}" />. For any given <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a" alt="a" title="a" />, the level set of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f" alt="f" title="f" /> may have several connected components. Intuitively, as we increase or decrease <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a" alt="a" title="a" />, these level sets may appear, disappear, merge, or split. This creates a tree, called the <em>contour tree</em>.</p>
<p>Informally speaking, the contour tree captures the &quot;skeleton&quot; of the scalar function. Nodes in the contour tree correspond to critical points of the function. The scalar value of a node in the contour tree is equal to the function's value at the corresponding point in the input space.</p>
<p>It is often the case that we have many samples of a scalar function defined on a potentially high-dimensional space, and we'd like to visualize it somehow. For example, we may want to visualize a probability distribution of many variables. In this case, our dataset is a point cloud. To visualize this data, we'll adopt the following strategy:</p>
<ol style="list-style-type: decimal">
<li><p>Build a neighbor graph by connecting each point in the dataset to its <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> nearest neighbors. <em>denali.py</em> provides a function to do this.</p></li>
<li><p>Compute the contour tree using <em>ctree</em>.</p></li>
<li><p>Visualize with <em>denali</em>.</p></li>
</ol>
<h2 id="building-a-neighbor-graph">Building a neighbor graph</h2>
<p>First, we need some data to visualize. Included in <code>examples/tutorial/data.txt</code> are 10000 samples of a probability density in 4 dimensions. If you'd like to see how the data is generated, you can look at <code>examples/tutorial/gendata.py</code>.</p>
<p>The format of the file is as follows: the first four columns specify the location of the sample. The fifth column denotes the (unnormalized) density of the function at that point.</p>
<p>The script contained in <code>examples/tutorial/makenngraph.py</code> reads this file and computes the 10-nearest-neighbor graph. It then outputs this graph in a format that <code>ctree</code> can use. If you were to open it, you'd find:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> numpy <span class="ch">as</span> np
<span class="ch">import</span> denali

data = np.loadtxt(<span class="st">&quot;data.txt&quot;</span>)

<span class="co"># separate the samples from the density</span>
samples = data[:,:<span class="dv">3</span>]
density = data[:,<span class="dv">4</span>]

<span class="co"># find the edges in a 10-nearest-neighbor graph</span>
edges = denali.contour.kneighbors_complex(samples, <span class="dv">10</span>)

<span class="co"># write the vertices and edges to a file</span>
denali.io.write_vertices(<span class="dt">open</span>(<span class="st">&quot;vertices.txt&quot;</span>, <span class="st">&#39;w&#39;</span>), density)
denali.io.write_edges(<span class="dt">open</span>(<span class="st">&quot;edges.txt&quot;</span>, <span class="st">&#39;w&#39;</span>), edges)</code></pre>
<p>Three utility functions included in <em>denali.py</em> are used here:</p>
<ul>
<li><p><code>kneighbors_complex</code> takes an array of points and the number of neighbors and builds a <em>k</em>nn graph, returning the edges as a list.</p></li>
<li><p><code>write_vertices</code> takes an open file-like object and an array of vertex values and writes the values to the file.</p></li>
<li><p><code>write_edges</code> takes an open file-like object and a list of edge pairs, such as those returned by <code>kneighbors_complex</code>, and writes them to the file.</p></li>
</ul>
<p>For more information on these functions, see the <a href="../pydoc/_build/html/index.html">python documentation</a>.</p>
<p>Running the above script will output two files: <code>vertices.txt</code> and <code>edges.txt</code>. We've included them in <code>examples/tutorial</code>, so you don't have to run the script above to proceed to the next step.</p>
<h2 id="computing-the-contour-tree">Computing the contour tree</h2>
<p><em>ctree</em> is a command-line tool for computing contour trees. It should have been installed alongside <em>denali</em>.</p>
<p><em>ctree</em> has three required arguments:</p>
<pre><code>ctree &lt;vertex value file&gt; &lt;edge file&gt; &lt;tree file&gt; </code></pre>
<p>The <em>vertex file</em> and <em>edge file</em> are the files we just created in the last step. The <em>tree file</em> will be overwritten by <em>ctree</em>: it's where the output will be placed.</p>
<p>In a terminal, navigate to the <code>examples/tutorial</code> directory and type</p>
<pre><code>ctree vertices.txt edges.txt tutorial.tree</code></pre>
<p>Now, start <em>denali</em> and load the <code>tutorial.tree</code> file. You should see a large peak with several other, smaller peaks surrounding it. If so, you've successfully visualized a scalar function defined on a point cloud.</p>
<p>For more information on how to use <em>ctree</em>, see the <a href="ctree.html">ctree documentation</a>.</p>
</div>
</body>
</html>
